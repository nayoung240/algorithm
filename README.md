# algorithm

## 스택/큐
* 스택/큐 > 기능개발 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42586)
[풀이](https://github.com/nayoung240/algorithm/blob/main/functiondevlop.py)
* 스택 수열 > 👉
[문제](https://www.acmicpc.net/problem/1874)
[풀이](https://github.com/nayoung240/algorithm/blob/main/stacknumber.py)
* 스택/큐 > 주식 가격 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42584)
[풀이](https://github.com/nayoung240/algorithm/blob/main/stockprice.py)
* 1~1000에서 각 숫자의 개수 구하기 > 👉
[문제](https://codingdojang.com/scode/504)
[풀이](https://github.com/nayoung240/algorithm/blob/main/numbercount.py)
* 2019 카카오 개발자 겨울 인턴십 > 크레인 인형뽑기 게임 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/64061?language=javascript)
[풀이](https://github.com/nayoung240/algorithm/blob/main/dolldraw.js)
* 큐2 > 👉
[문제](https://www.acmicpc.net/problem/18258)
[풀이](https://github.com/nayoung240/algorithm/blob/main/queue.py)
* 2022 KAKAO TECH INTERNSHIP > 두 큐 합 같게 만들기 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/118667)
[풀이](https://github.com/nayoung240/algorithm/blob/main/samequeue.py)

## 힙/해시
* 해시 > 완주하지 못한 선수 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42576?language=python3#_=_)
[풀이](https://github.com/nayoung240/algorithm/blob/main/uncomplete.py)
* Kth Largest Element in an Array > 👉
[문제](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/kthlagest.py)
* Kth Smallest Element in a Sorted Matrix > 👉
[문제](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/kthsmallest.py)
* Group Anagrams > 👉
[문제](https://leetcode.com/problems/group-anagrams/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/groupanagram.py)
* Letter Combinations of a Phone Number > 👉
[문제](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/phonenumbercombination.py)
* 2019 KAKAO BLIND RECRUITMENT > 오픈채팅방 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42888)
[풀이](https://github.com/nayoung240/algorithm/blob/main/openchat.py)
* 2022 KAKAO BLIND RECRUITMENT > 신고 결과 받기 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
[풀이](https://github.com/nayoung240/algorithm/blob/main/reportmail.py)


## 정렬
* 정렬 > H-Index 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42747)
[풀이](https://github.com/nayoung240/algorithm/blob/main/hindex.py)
* 정렬 > 소트인사이드 👉
[문제](https://www.acmicpc.net/problem/1427)
[풀이](https://github.com/nayoung240/algorithm/blob/main/sortinside.py)
* 정렬 > 가장 큰 수 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42746?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/biggestnumber.py)


## 완전 탐색
* 완전탐색 > 카펫 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42842)
[풀이](https://github.com/nayoung240/algorithm/blob/main/carpet.py)
* 이분탐색 > 입국심사 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
[풀이](https://github.com/nayoung240/algorithm/blob/main/immigration.py)


## 탐욕법 (Greedy)
* 탐욕법(Greedy) > 체육복 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42862)
[풀이](https://github.com/nayoung240/algorithm/blob/main/gymsuit.py)


## 동적계획법 (Dynamic Programming)
* 동적계획법(Dynamic Programming) > 정수 삼각형 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43105)
[풀이](https://github.com/nayoung240/algorithm/blob/main/inttriangle.py)
* 동적계획법(Dynamic Programming) > N으로 표현 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42895)
[풀이](https://github.com/nayoung240/algorithm/blob/main/nreturn.py)


## 깊이 우선 탐색 / 넓이 우선 탐색 (DFS/BFS)
* 깊이우선탐색(DFS) 타겟 넘버 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43165?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/targetnumber.py)


## 기타
* 2021 KAKAO BLIND RECRUITMENT > 신규 아이디 추천 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/72410)
[풀이](https://github.com/nayoung240/algorithm/blob/main/newid.js)
[풀이2](https://github.com/nayoung240/algorithm/blob/main/newid.py)
* 위클리 챌린지 > 부족한 금액 계산하기 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/82612)
[풀이](https://github.com/nayoung240/algorithm/blob/main/lackmoney.py)
* 위클리 챌린지 > 상호평가 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/83201)
[풀이](https://github.com/nayoung240/algorithm/blob/main/evaluation.py)
* 스킬 체크 테스트 Level1 👉
[문제](https://programmers.co.kr/skill_checks/403872)
[풀이](https://github.com/nayoung240/algorithm/blob/main/caldate.py)

<br>

## sql
* 2021 Dev-Matching: 웹 백엔드 개발자(상반기) > 헤비 유저가 소유한 장소
[문제](https://programmers.co.kr/learn/courses/30/lessons/77487)
[풀이](https://github.com/nayoung240/algorithm/blob/main/havyuser.sql)

<br>

## 코딩테스트 사이트
- 프로그래머스
- 백준
- leetcode

<br><hr><br>

# 알아두면 쓸모있는?!

여러줄 입력받을 때 타임아웃 걸리지 않으려면
```
import sys 
T = int(input()) 
for i in range(T): 
    a,b = map(int, sys.stdin.readline().split()) 
```

개행문자까지 입력받기
```
sys.stdin.readline().strip()
```

2차원 배열을 1차원 배열로 합치기
```
sum(matrix,[])
```

여러 그룹의 데이터를 루프를 한 번만 돌면서 병렬 처리 가능 (묶기)
```
zip([1,2,3],['a','b','c']) # (1,'a'),(2,'b'),(3,'c')
```

소수점
```
round(number) # 반올림

import math
math.ceil(number) # 올림
```


for문 돌면서 popleft하게되면 에러가 발생한다.
```
import copy
for i in copy.deepcopy(workday):
```

deque
- popleft() 필요할 때 효율성 높음
```
from collections import deque 
workday = deque()
```

defaultdict(int) 를 사용하면 if 미리 존재하는지 체크안해도 된다.
dictionary의 초기값은 0으로 지정되기때문이다.
```
for j in strarr:
    if j in counts:
        counts[j] += 1
    else:
        counts[j] = 1
```
```
from collections import defaultdict
counts = defaultdict(int)
for j in strarr:
    counts[j] += 1
```

리스트 요소들 사이에 sep 구분자를 넣어 출력하기  
```
print(*answer, sep='\n')
```

counter
- {객체값 : counter수}
- counter 객체 간 더하기, 빼기, 교집합, 합집합 연산 가능
```
import collections
answer = collections.Counter(participant) - collections.Counter(completion)
```

정렬
- sort(): 리스트 원본값을 수정한다, 리턴값은 None
- sorted(): 리스트 원본값은 그대로, 리턴값은 정렬값

중복제거&정렬하기
```
sorted(set(nums), reverse=True)
```

순열
- permutations(): 하나의 리스트에서 모든 조합 계산(순서포함)
```
from itertools import permutations
permutations(arr, 2)
```

조합
- combinations(): 하나의 리스트에서 모든 조합 계산
- product(): 두개 이상의 리스트에서 모든 조합 계산
```
from itertools import product
combinations(arr, 2)
product(*arr)
```


튜플을 문자열로 변환하기
```
''.join(튜플)
```

set 집합 자료형
- 중복을 제거한다.
- 추가: add()
- 제거: remove()
- 교집합: list(set(A) & set(B))
- 합집합: list(set(A) | set(B))
- 차집합: list(set(A) - set(B))


윤년은 2월이 29일이다.


sort key lambda
key인자에 함수를 넘겨주면 우선순위가 정해진다
```
d = sorted(a, key = lambda x : x[1]) 
d = [(3, 0), (5, 1), (0, 1), (1, 2), (5, 2)]
```


이분탐색
```
left, right
while left <= right:
    mid = (left+right)//2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        right = mid-1
    else:
        left = mid+1
```


DFS
1. 탐색 시작 노드를 스택에 삽입 후 방문처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
```
def dfs(graph, v, visited):
    # 현재 노드 방문 처리
    visited[v] = True
    print(v, end=' ')

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
```

BFS
1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼내 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리 한다.
```
from collections import deque

def bfs(graph, start, visited):
    queue = deque([start])
    # node visited
    visited[start] = True

    # loop till queue is empty
    while queue:
        # visted node 'v' 
        v = queue.popleft()
        print(v, end=' ')

        # v 노드에 연결된 노드들 투입 -> 방문 안한 노드만 queue에 추가
        for i in graph[v]:
            if not visited[i]:
               queue.append(i)
               # print(queue) # queue안에 뭐있나
               visited[i] = True
```

정렬 알고리즘
- Bubble Sort(버블정렬): 첫 원소부터 순차로 현재 원소가 그 다음 원소보다 크면 두 원소를 바꿈
- Selection Sort(선택정렬): 배열을 선형 탐색(linear scan)하여 가장 작은 원소를 앞으로 보냄
- Insertion Sort(삽입정렬): 적절한 위치에 삽입(insertion)하는 정렬. 필요할 때만 위치를 바꾸므로 데이터가 정렬되어있을 때는 효율적임.
- Quick Sort(퀵정렬): 임의의 기준 대비 큰 수와 작은 수로 나누는 방식
- Merge Sort(병합정렬): 배열을 절반씩 나누어 각각 정렬하고 합해서 다시 정렬

선택 정렬
```
array = [2, 3, 1, 4]
for i in range(len(array)):
    min_index = i # index of the smallest element
    for j in range(i+1, len(array)):
        min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap
```

분할정복
```
array = [2, 3, 1, 4]
def quick_sort(array):
    #quit if list has one or less elements
    if len(array) <= 1:
        return array
    
    pivot = array[0] # first element as pivot
    tail = array[1:] # list accept pivot
    left = [x for x in tail if x <= pivot] # left side
    right = [x for x in tail if x > pivot] # right side
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
```

문자열 정해진 수를 0으로 채우기
```
'8'.zfill(3) #008
```
