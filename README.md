# algorithm

## ìŠ¤íƒ/í
* ìŠ¤íƒ/í > ê¸°ëŠ¥ê°œë°œ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42586)
[í’€ì´](/stackandqueue/functiondevlop.py)
* ìŠ¤íƒ ìˆ˜ì—´ > ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/1874)
[í’€ì´](/stackandqueue/stacknumber.py)
* ìŠ¤íƒ/í > ì£¼ì‹ ê°€ê²© > ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42584)
[í’€ì´](/stackandqueue/stockprice.py)
* 1~1000ì—ì„œ ê° ìˆ«ìì˜ ê°œìˆ˜ êµ¬í•˜ê¸° > ğŸ‘‰
[ë¬¸ì œ](https://codingdojang.com/scode/504)
[í’€ì´](/stackandqueue/numbercount.py)
* 2019 ì¹´ì¹´ì˜¤ ê°œë°œì ê²¨ìš¸ ì¸í„´ì‹­ > í¬ë ˆì¸ ì¸í˜•ë½‘ê¸° ê²Œì„ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/64061?language=javascript)
[í’€ì´](/stackandqueue/dolldraw.js)
* í2 > ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/18258)
[í’€ì´](/stackandqueue/queue.py)
* 2022 KAKAO TECH INTERNSHIP > ë‘ í í•© ê°™ê²Œ ë§Œë“¤ê¸° > ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/118667)
[í’€ì´](/stackandqueue/samequeue.py)
* ìŠ¤íƒ/í > ë‹¤ë¦¬ë¥¼ ì§€ë‚˜ëŠ” íŠ¸ëŸ­ > ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42583)
[í’€ì´](/stackandqueue/bridge_truck.py)
* ìŠ¤íƒ/í > Brackets > ğŸ‘‰
[ë¬¸ì œ](https://app.codility.com/programmers/lessons/7-stacks_and_queues/brackets/start/)
[í’€ì´](/stackandqueue/brackets.py)



## í™/í•´ì‹œ
* í•´ì‹œ > ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42576?language=python3#_=_)
[í’€ì´](/heapandhash/uncomplete.py)
* Kth Largest Element in an Array > ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
[í’€ì´](/heapandhash/kthlagest.py)
* Kth Smallest Element in a Sorted Matrix > ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
[í’€ì´](/heapandhash/kthsmallest.py)
* Group Anagrams > ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/group-anagrams/description/)
[í’€ì´](/heapandhash/groupanagram.py)
* Letter Combinations of a Phone Number > ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
[í’€ì´](/heapandhash/phonenumbercombination.py)
* 2019 KAKAO BLIND RECRUITMENT > ì˜¤í”ˆì±„íŒ…ë°© ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42888)
[í’€ì´](/heapandhash/openchat.py)
* 2022 KAKAO BLIND RECRUITMENT > ì‹ ê³  ê²°ê³¼ ë°›ê¸° ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
[í’€ì´](/heapandhash/reportmail.py)


## ì •ë ¬
* ì •ë ¬ > H-Index ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42747)
[í’€ì´](/sort/hindex.py)
* ì •ë ¬ > ì†ŒíŠ¸ì¸ì‚¬ì´ë“œ ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/1427)
[í’€ì´](/sort/sortinside.py)
* ì •ë ¬ > ê°€ì¥ í° ìˆ˜ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42746?language=python3)
[í’€ì´](/sort/biggestnumber.py)
* triangle ğŸ‘‰
[ë¬¸ì œ](https://app.codility.com/programmers/lessons/6-sorting/triangle/start/)
[í’€ì´](/sort/triangle.py)


## ì™„ì „ íƒìƒ‰
* ì™„ì „íƒìƒ‰ > ì¹´í« ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42842)
[í’€ì´](/brouteforce/carpet.py)


## ì´ë¶„ íƒìƒ‰
* ì´ë¶„íƒìƒ‰ > ì…êµ­ì‹¬ì‚¬ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
[í’€ì´](/binary/immigration.py)
* 2020 KAKAO BLIND RECRUITMENT > ê°€ì‚¬ ê²€ìƒ‰ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/60060?language=python3)
[í’€ì´](/binary/searchlycies.py)
* ì˜ˆì‚° ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/2512)
[í’€ì´](/binary/budget.py)
* ì§•ê²€ë‹¤ë¦¬ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/43236?language=python3)
[í’€ì´](/binary/steppingstone.py)

## íƒìš•ë²• (Greedy)
* íƒìš•ë²•(Greedy) > ì²´ìœ¡ë³µ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/42862)
[í’€ì´](/greedy/gymsuit.py)


## ë™ì ê³„íšë²• (Dynamic Programming)
* ë™ì ê³„íšë²•(Dynamic Programming) > ì •ìˆ˜ ì‚¼ê°í˜• ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/43105)
[í’€ì´](/dp/inttriangle.py)
* ë™ì ê³„íšë²•(Dynamic Programming) > Nìœ¼ë¡œ í‘œí˜„ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42895)
[í’€ì´](/dp/nreturn.py)
* ë™ì ê³„íšë²•(Dynamic Programming) > ë„ë‘‘ì§ˆ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/42897)
[í’€ì´](/dp/thievery.py)
* Unique Paths ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/unique-paths/)
[í’€ì´](/dp/uniquepath.py)
* ì—°ì† ë¶€ë¶„ ìˆ˜ì—´ í•©ì˜ ê°œìˆ˜ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/131701?language=python3)
[í’€ì´](/dp/circlesum.py)
* Longest Increasing Subsequence ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/longest-increasing-subsequence/)
[í’€ì´](/dp/lis.py)
* Word Break ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/word-break)
[í’€ì´](/dp/wordbreak.py)


## ê¹Šì´ ìš°ì„  íƒìƒ‰ / ë„“ì´ ìš°ì„  íƒìƒ‰ (DFS/BFS)
* ê¹Šì´ìš°ì„ íƒìƒ‰(DFS) íƒ€ê²Ÿ ë„˜ë²„ > ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/43165?language=python3)
[í’€ì´](/dfsbfs/targetnumber.py)
* DFSì™€ BFS > ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/1260)
[í’€ì´](/dfsbfs/dfsbfs.py)
* ì„œìš¸ ì§€í•˜ì²  2í˜¸ì„  > ğŸ‘‰
[ë¬¸ì œ](https://www.acmicpc.net/problem/16947)
[í’€ì´]/dfsbfs/station2line.py)
* Numbers With Same Consecutive Differences > ğŸ‘‰
[ë¬¸ì œ](https://leetcode.com/problems/numbers-with-same-consecutive-differences/)
[í’€ì´](/dfsbfs/samediffnum.py)


## ê¸°íƒ€
* 2021 KAKAO BLIND RECRUITMENT > ì‹ ê·œ ì•„ì´ë”” ì¶”ì²œ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/72410)
[í’€ì´](https://github.com/nayoung240/algorithm/blob/main/newid.js)
[í’€ì´2](/etc/newid.py)
* ìœ„í´ë¦¬ ì±Œë¦°ì§€ > ë¶€ì¡±í•œ ê¸ˆì•¡ ê³„ì‚°í•˜ê¸° ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/82612)
[í’€ì´](/etc/lackmoney.py)
* ìœ„í´ë¦¬ ì±Œë¦°ì§€ > ìƒí˜¸í‰ê°€ ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/83201)
[í’€ì´](/etc/evaluation.py)
* ìŠ¤í‚¬ ì²´í¬ í…ŒìŠ¤íŠ¸ Level1 ğŸ‘‰
[ë¬¸ì œ](https://programmers.co.kr/skill_checks/403872)
[í’€ì´](/etc/caldate.py)
* 2021 Dev-Matching: ì›¹ ë°±ì—”ë“œ ê°œë°œì(ìƒë°˜ê¸°) > ë‹¤ë‹¨ê³„ í”¼ë¼ë¯¸ë“œ ğŸ‘‰
[ë¬¸ì œ](https://school.programmers.co.kr/learn/courses/30/lessons/77486?language=python3)
[í’€ì´](/etc/pyramid.py)


## ì„±ëŠ¥
* OddOccurrencesInArray ğŸ‘‰
[ë¬¸ì œ](https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/start/)
[í’€ì´](/performance/oddinarray.py)
* FrogRiverOne ğŸ‘‰
[ë¬¸ì œ](https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/start/)
[í’€ì´](/performance/frogreverone.py)

<br>

## sql
* 2021 Dev-Matching: ì›¹ ë°±ì—”ë“œ ê°œë°œì(ìƒë°˜ê¸°) > í—¤ë¹„ ìœ ì €ê°€ ì†Œìœ í•œ ì¥ì†Œ
[ë¬¸ì œ](https://programmers.co.kr/learn/courses/30/lessons/77487)
[í’€ì´](/sql/havyuser.sql)

<br>

## ì½”ë”©í…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸
- í”„ë¡œê·¸ë˜ë¨¸ìŠ¤
  - ì¥ì : íšŒì‚¬ ê¸°ì¶œ ë¬¸ì œ ëª¨ìŒ ì œê³µ, ì˜¨ë¼ì¸ IDE ì œê³µ, í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ ì¶”ê°€ ê°€ëŠ¥
- ë°±ì¤€ 
  - ì¥ì : ë‹¤ì–‘í•œ ë¬¸ì œ, ë§ì€ í’€ì´
- leetcode
  - ì¥ì : ì˜ì–´ë¬¸ì œ, ì˜¨ë¼ì¸ IDE ì œê³µ 
- codility
  - ì¥ì : ì˜ì–´ë¬¸ì œ, ì˜¨ë¼ì¸ IDE ì œê³µ, ì„±ëŠ¥ì‹œê°„ ë¶„ì„ ì œê³µ 

<br><hr><br>

# ì•Œì•„ë‘ë©´ ì“¸ëª¨ìˆëŠ”?! ë‚˜ë§Œì˜ Cheat seat

## âœ¨ì…ë ¥ ë°›ê¸°
### ì—¬ëŸ¬ì¤„ ì…ë ¥ë°›ì„ ë•Œ íƒ€ì„ì•„ì›ƒ ê±¸ë¦¬ì§€ ì•Šìœ¼ë ¤ë©´
```
import sys 
T = int(input()) 
for i in range(T): 
    a,b = map(int, sys.stdin.readline().split()) 
```

### ê°œí–‰ë¬¸ìê¹Œì§€ ì…ë ¥ë°›ê¸°
```
import sys
sys.stdin.readline().strip()
```

### ë¶„ë¦¬í•˜ì—¬ ì…ë ¥ë°›ê¸°
```
import sys
n = list(map(int, sys.stdin.readline().split()))
```

## âœ¨map(function, iterable)

### mapì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ forë¬¸ìœ¼ë¡œ ë²ˆê±°ë¡œì›€
```
myList = [1, 2, 3, 4, 5]

# for ë°˜ë³µë¬¸ ì´ìš©
result1 = []
for val in myList:
    result1.append(val + 1)
```
### mapì„ ì‚¬ìš©í•  ë•Œ
```
myList = [1, 2, 3, 4, 5]

def add_one(n):
    return n + 1

result2 = list(map(add_one, myList))  # mapë°˜í™˜ì„ list ë¡œ ë³€í™˜
```
### map, lamda í•¨ìˆ˜(ì´ë¦„ì—†ëŠ” í•¨ìˆ˜) ì´ìš©
```
result2 = list(map(lambda x: x * 2, [5, 4, 3, 2, 1]))
```

## âœ¨counter
- return dictionaryí˜• {ê°ì²´ê°’ : counterìˆ˜}
- counter ê°ì²´ ê°„ ë”í•˜ê¸°, ë¹¼ê¸°, êµì§‘í•©, í•©ì§‘í•© ì—°ì‚° ê°€ëŠ¥
- ì‹œê°„ ë³µì¡ë„: O(N)
  - forë¬¸ì„ í†µí•´ì„œ countí•˜ë©´ ì‹œê°„ë³µì¡ë„ê°€ O(N**2) ì´ì§€ë§Œ counterëŠ” countë¥¼ në²ˆ í•˜ëŠ” ê²ƒì´ë¼ ë¹ ë¥´ë‹¤.
```
import collections
answer = collections.Counter(participant) - collections.Counter(completion)
```

## âœ¨ì†Œìˆ˜ì 
```
round(number) # ë°˜ì˜¬ë¦¼

import math
math.ceil(number) # ì˜¬ë¦¼
```

## âœ¨ì •ë ¬
- sort(): ë¦¬ìŠ¤íŠ¸ ì›ë³¸ê°’ì„ ìˆ˜ì •í•œë‹¤, ë¦¬í„´ê°’ì€ None (sorted ë³´ë‹¤ ì¡°ê¸ˆ ë¹ ë¥´ë‹¤)
- sorted(): ë¦¬ìŠ¤íŠ¸ ì›ë³¸ê°’ì€ ê·¸ëŒ€ë¡œ, ë¦¬í„´ê°’ì€ ì •ë ¬ê°’

### ì¤‘ë³µì œê±°&ì •ë ¬í•˜ê¸°
```
sorted(set(nums), reverse=True)
```

### lamda ì¸ì : í‘œí˜„ì‹ 
- keyì¸ìì— ì •ë ¬í•´ì¤„ ê°’ì„ ë„˜ê²¨ì£¼ë©´ ì •ë ¬ëœë‹¤ 

### list[1]ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
```
sorted(a, key = lambda x : x[1]) # [(3, 0), (5, 1), (0, 1), (1, 2), (5, 2)]
```
### ë¬¸ìì—´ ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
```
sorted(list, key=lambda x : len(x)) # ['is', 'my', 'name', 'song']
```
### ì œì¼ í° ìˆ˜ ë§Œë“¤ê¸°
```
list.sort(key=lambda x:str(x)*3, reverse=True)
```

## âœ¨ìˆœì—´
- permutations(): í•˜ë‚˜ì˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ëª¨ë“  ì¡°í•© ê³„ì‚°(ìˆœì„œí¬í•¨)
```
from itertools import permutations
permutations(arr, 2)
```

## âœ¨ì¡°í•©
- combinations(): í•˜ë‚˜ì˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ëª¨ë“  ì¡°í•© ê³„ì‚°
```
import itertools

a = itertools.combinations([2,1,3], 2)
print(list(a)) # [(2,1),(2,3),(1,3)]
```
- product(): ë‘ê°œ ì´ìƒì˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ëª¨ë“  ì¡°í•© ê³„ì‚°
```
from itertools import product
product(*arr)
```

## âœ¨í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´
```
def fibonacci(a):
    if a < 2:
        return a
    return fibonacci(a-2) + fibonacci(a-1)
```

## âœ¨set ì§‘í•© ìë£Œí˜•
- ì¤‘ë³µì„ ì œê±°í•œë‹¤.
- ì¶”ê°€: add()
- ì œê±°: remove()
- êµì§‘í•©: list(set(A) & set(B))
- í•©ì§‘í•©: list(set(A) | set(B))
- ì°¨ì§‘í•©: list(set(A) - set(B))


## âœ¨í™ heap
: ì—¬ëŸ¬ê°œì˜ ê°’ë“¤ ì¤‘ì—ì„œ ìµœëŒ€ê°’ì´ë‚˜ ìµœì†Ÿê°’ì„ ë¹ ë¥´ê²Œ ì°¾ë„ë¡ ë§Œë“¤ì–´ì§„ ìë£Œêµ¬ì¡°

- ì´ì§„ íŠ¸ë¦¬ êµ¬ì¡°
- ê° ë…¸ë“œì˜ ê°’ì€ ìì‹ ë…¸ë“œë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤. (ì´ì§„íƒìƒ‰ íŠ¸ë¦¬ì™€ì˜ ì°¨ì´ì )
- ë‘ ìì‹ ì¤‘ ë” í° ìì‹ê³¼ ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ë°”ê¾¸ëŠ” ì•Œê³ ë¦¬ì¦˜
- ìµœì•…ì€ O(logN)

### ìµœì†Œí™ (ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬)
: ë¶€ëª¨ë…¸ë“œì˜ ê°’ì´ ìì‹ë…¸ë“œì˜ ê°’ë³´ë‹¤ í•­ìƒ ì‘ë‹¤.
```
import heapq

def heapsort(iterable):
    h = []
    result = []

    #ëª¨ë“  ì›ì†Œë¥¼ ì°¨ë¡€ëŒ€ë¡œ í™ì— ì‚½ì…
    for value in iterable:
        heapq.heappush(h,value)
    
    #í™ì— ì‚½ì…ëœ ëª¨ë“  ì›ì†Œë¥¼ ì°¨ë¡€ëŒ€ë¡œ êº¼ë‚´ì–´ ë‹´ê¸°
    for _ in range(len(h)):
        result.append(heapq.heappop(h))
    
    return result

result = heapsort([1,3,5,7,9,2,4,6,8,0])
print(result)
```

### ìµœëŒ€í™ (ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬)
: ë¶€ëª¨ë…¸ë“œì˜ ê°’ì´ ìì‹ë…¸ë“œì˜ ê°’ë³´ë‹¤ í•­ìƒ í¬ë‹¤.
```
import heapq

def heapsort(iterable):
    r = []
    result = []

    for value in iterable:
        heapq.heappush(r,-value)
    
    for _ in range(len(r)):
        result.append(-heapq.heappop(r))

    return result

result = heapsort([1,3,5,7,9,2,4,6,8,0])
print(result)
```

## âœ¨ Dijkstra ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
- ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸° (ë…¸ë“œ, ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê°„ì„ )
- í•œ ì§€ì ì—ì„œ ë‹¤ë¥¸ ì§€ì ê¹Œì§€ ìµœë‹¨ ê²½ë¡œ
- ìš°ì„ ìˆœìœ„ í heapq : ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ë°ì´í„°ë¥¼ ê°€ì¥ ë¨¼ì € êº¼ë‚¸ë‹¤
- ê±°ë¦¬ ë¦¬ìŠ¤íŠ¸, ë°©ë¬¸ì—¬ë¶€ ë¦¬ìŠ¤íŠ¸

1. ì¶œë°œ ë…¸ë“œ ì„¤ì •í•œë‹¤
2. ì¶œë°œ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê° ë…¸ë“œì˜ ìµœì†Œ ë¹„ìš©ì„ ì €ì¥í•œë‹¤
3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ ê°€ì¥ ë¹„ìš©ì´ ì ì€ ë…¸ë“œë¥¼ ì„ íƒí•œë‹¤
4. í•´ë‹¹ ë…¸ë“œë¥¼ ê±°ì³ì„œ íŠ¹ì •í•œ ë…¸ë“œë¡œ ê°€ëŠ¥ ê²½ìš°ë¥¼ ê³ ë ¤í•˜ì—¬ ìµœì†Œ ë¹„ìš©ì„ ê°±ì‹ í•œë‹¤
5. 3~4ë²ˆ ë°˜ë³µ
```
import sys
import heapq
input = sys.stdin.readline
n, m = map(int, input().split())
start = int(input())
INF = int(1e9)

distance = [INF] * (n+1)
graph = [[] for _ in range(n+1)]

for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))


def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))  # ì‹œì‘ë…¸ë“œ ì •ë³´ ìš°ì„ ìˆœìœ„ íì— ì‚½ì…
    distance[start] = 0            # ì‹œì‘ë…¸ë“œ->ì‹œì‘ë…¸ë“œ ê±°ë¦¬ ê¸°ë¡

    while q:
        dist, node = heapq.heappop(q)

        # íì—ì„œ ë½‘ì•„ë‚¸ ê±°ë¦¬ê°€ ì´ë¯¸ ê°±ì‹ ëœ ê±°ë¦¬ë³´ë‹¤ í´ ê²½ìš°(=ë°©ë¬¸í•œ ì…ˆ) ë¬´ì‹œ
        if distance[node] < dist:
            continue

        # íì—ì„œ ë½‘ì•„ë‚¸ ë…¸ë“œì™€ ì—°ê²°ëœ ì¸ì ‘ë…¸ë“œë“¤ íƒìƒ‰
        for next in graph[node]:
            cost = distance[node] + next[1]   # ì‹œì‘->nodeê±°ë¦¬ + node->nodeì˜ì¸ì ‘ë…¸ë“œ ê±°ë¦¬
            if cost < distance[next[0]]:      # cost < ì‹œì‘->nodeì˜ì¸ì ‘ë…¸ë“œ ê±°ë¦¬
                distance[next[0]] = cost
                heapq.heappush(q, (cost, next[0]))

dijkstra(start)

for i in range(1, len(distance)):
    if distance[i] == INF:
        print('ë„ë‹¬í•  ìˆ˜ ì—†ìŒ')
    else:
        print(distance[i])
```

## âœ¨ì´ë¶„íƒìƒ‰, ì´ì§„ íƒìƒ‰, Binary Search

: íƒìƒ‰ ë²”ìœ„ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì—¬ê°€ë©´ì„œ ì›í•˜ëŠ” ìˆ«ì(target)ë¥¼ ì°¾ê¸°

- íƒ€ê²Ÿì„ ì°¾ì„ ë•Œì—ëŠ” ë°°ì—´ì•ˆì˜ ê°’ì€ ë°˜ë“œì‹œ ì •ë ¬ë˜ì–´ìˆì–´ì•¼ í•œë‹¤.
- O(N)ì´ ê±¸ë¦´ íƒìƒ‰ì„ O(logN)ìœ¼ë¡œ ì¤„ì—¬ì¤€ë‹¤.
- Parametric SearchëŠ” ì£¼ì–´ì§„ ë²”ìœ„ ë‚´ì—ì„œ ì›í•˜ëŠ” ê°’ ë˜ëŠ” ì¡°ê±´ì— ê°€ì¥ ì¼ì¹˜í•˜ëŠ” ê°’ì„ ì°¾ì•„ë‚´ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. ì´ëŸ° í˜•íƒœì˜ ë¬¸ì œë¥¼ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ í•´ê²°í•œë‹¤.

```
left, right = 0, max(arr)

while left <= right:
    mid = (left + right)//2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        right = mid-1
    else:
        left = mid+1

return -1 #ì°¾ì§€ ëª»í–ˆì„ ë•Œ
```

### bisect_left(a, x)
- ì •ë ¬ëœ aì— xë¥¼ ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ë¦¬í„´í•œë‹¤.
- xê°€ ì´ë¯¸ ìˆìœ¼ë©´ xìœ„ì¹˜ì˜ ì• ìœ„ì¹˜ë¥¼ ë¦¬í„´í•œë‹¤.

### bisect_right(a, x)
- xê°€ ì´ë¯¸ ìˆìœ¼ë©´ xìœ„ì¹˜ì˜ ë’¤ ìœ„ì¹˜ë¥¼ ë°˜í™˜í•œë‹¤.

=> ê°’ì´ ì—†ì„ ë•ŒëŠ” ê°™ì€ ê°’ ë¦¬í„´
=> ê°’ì´ ìˆì„ ë•Œ ì™¼ìª½ì„ ë¦¬í„´í• ì§€ vs ì˜¤ë¥¸ìª½ì„ ë¦¬í„´í• ì§€ ì°¨ì´

## âœ¨DFS
1. íƒìƒ‰ ì‹œì‘ ë…¸ë“œë¥¼ ìŠ¤íƒì— ì‚½ì… í›„ ë°©ë¬¸ì²˜ë¦¬
2. ìŠ¤íƒì˜ ìµœìƒë‹¨ ë…¸ë“œì— ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œê°€ ìˆìœ¼ë©´ ì¸ì ‘ ë…¸ë“œë¥¼ ìŠ¤íƒì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬. ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œê°€ ì—†ìœ¼ë©´ ìŠ¤íƒì—ì„œ ìµœìƒë‹¨ ë…¸ë“œë¥¼ êº¼ë‚¸ë‹¤.

### ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„ "set, stack, root, visited"
```
graph = {1: set([3, 4]),
              2: set([3, 4, 5]),
              3: set([1, 5]),
              4: set([1]),
              5: set([2, 6]),
              6: set([3, 5])}
root = 1

def dfs(graph, root):
    visited = []
    stack = [root]

    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            stack += graph[n] - set(visited)
    return visited

dfs(graph, root)
```

### ì¬ê·€ë¡œ êµ¬í˜„
```
def dfs(graph, v, visited):
    # í˜„ì¬ ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
    visited[v] = True

    # í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë°©ë¬¸
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
```

- íŒŒì´ì¬ì€ ì¬ê·€í˜¸ì¶œ íšŸìˆ˜ê°€ 1000íšŒë¡œ ì œí•œë˜ì–´ sys ëª¨ë“ˆì˜ setrecursionlimit()ìœ¼ë¡œ ì œí•œì„ ëŠ˜ë ¤ì¤Œ
```
import sys
sys.setrecursionlimit(10**6)

def dfs(i):
    for j in range(1, N+1):
        if adf[i][j] and not chk[j]:
            chk[j] = True
            dfs(j)
```

### ì–‘ë°©í–¥ ê·¸ë˜í”„ êµ¬í˜„ "set, deque, root, visited, sort(reverse=True)"
```
def DFS(graph, root):
    visited = []
    stack = [root]

    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            if n in graph:
                temp = list(set(graph[n]) - set(visited))
                temp.sort(reverse=True)
                stack += temp
    return " ".join(str(i) for i in visited)
```

### ì‚¬ì´í´ ì°¾ê¸°
```
stack = [0]
while stack:
    n = stack.pop()
    for i in adj[n]:
        if not i in visited:
            stack.append(i)
    visited.append(n)
return visited
# visitedì— ì¤‘ë³µëœ ë…¸ë“œê°€ ìˆì„ ê²½ìš° ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ê³  íŒë‹¨!
```

## âœ¨ë°±íŠ¸ë˜í‚¹ backtracking
ì›í•˜ëŠ” ê°’ê³¼ ë¶ˆì¼ì¹˜ í•˜ëŠ” ë¶€ë¶„ì´ ìˆìœ¼ë©´ ë”ì´ìƒ íƒìƒ‰í•˜ì§€ ì•Šê³  ì „ ë‹¨ê³„ë¡œ ëŒì•„ê°„ë‹¤.
- Promising: íŠ¸ë¦¬êµ¬ì¡° ê¸°ë°˜ìœ¼ë¡œ DFS íƒìƒ‰í•˜ë©´ì„œ ì¡°ê±´ì— ë¶€í•©í•˜ëŠ”ì§€ ì²´í¬
- Pruning: ì¡°ê±´ì— ë§ì§€ ì•ŠëŠ” ë…¸ë“œëŠ” ê°€ì§€ì¹˜í‚¤í•œë‹¤.
ex) ë¯¸ë¡œ ì°¾ê¸° (íŠ¸ë¦¬ íƒìƒ‰ ë¬¸ì œë¡œ í•´ì„), n-queens

```
n, m = map(int, input().split())
visited = [False] * (n+1)
answer = []

def dfs(depth, n, m):
  if depth == m:
    print(' '.join(map(str, answer)))

  for i in range(1, n+1):
    # ë°©ë¬¸í•˜ì§€ ì•Šì•˜ì„ ê²½ìš°
    if not visited[i]:
      visited[i] = True
      answer.append(i)
      dfs(depth+1, n, m) # depth 1 ì¦ê°€, ë‹¤ìŒ ë…¸ë“œ
      visited[i] = False
      answer.pop()

dfs(0, n, m)
```

## âœ¨BFS
1. íƒìƒ‰ ì‹œì‘ ë…¸ë“œë¥¼ íì— ì‚½ì…í•˜ê³  ë°©ë¬¸ì²˜ë¦¬
2. íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ ì¸ì ‘ ë…¸ë“œ ì¤‘ì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë¥¼ ëª¨ë‘ íì— ì‚½ì…í•˜ê³  ë°©ë¬¸ì²˜ë¦¬ í•œë‹¤.

### íë¡œ êµ¬í˜„ "set, deque, root, visited"
```
from collections import deque

graph = {1: set([3, 4]),
              2: set([3, 4, 5]),
              3: set([1, 5]),
              4: set([1]),
              5: set([2, 6]),
              6: set([3, 5])}
root = 1

def bfs(graph, root):
    visited = []
    queue = deque([root])

    while queue:
        n = queue.popleft()
        if n not in visited:
            visited.append(n)
            queue += graph[n] - set(visited)
    return visited
    
bfs(graph, root)
```

### ì–‘ë°©í–¥ ê·¸ë˜í”„ êµ¬í˜„ "set, deque, root, visited, sort"
```
from collections import deque

graph = {1:[2,3,4], 2:[1,4], 3:[1,4], 4:[1,2,3]}
root = 1

def BFS(graph, root):
    visited = []
    queue = deque([root])

    while queue:
        n = queue.popleft()
        if n not in visited:
            visited.append(n)
            if n in graph:
                temp = list(set(graph[n]) - set(visited))
                temp.sort()
                queue += temp
    return " ".join(str(i) for i in visited)
    
BFS(graph, root)
```

### ë°©í–¥ ê·¸ë˜í”„ ìˆœí™˜ íƒì§€

1. ìµœì´ˆì— ë‚´ì°¨ìˆ˜ê°€ 0ì¸ ì •ì ì„ ëª¨ë‘ ì°¾ì•„ ê° ì •ì ì„ íì— ë„£ëŠ”ë‹¤.
2. íì—ì„œ í•˜ë‚˜ì”© ë¹¼ì„œ ë°©ë¬¸ ì™„ë£Œ ì²˜ë¦¬í•˜ê³  ë°©ë¬¸ ì™„ë£Œ ì •ì ì˜ ìˆ˜ë¥¼ 1 ëŠ˜ë¦¬ê³ , í•´ë‹¹ ì •ì ì˜ ì¸ì ‘ ì •ì ì˜ ë‚´ì°¨ìˆ˜ë¥¼ 1ì”© ëº€ ë‹¤ìŒ, ì¸ì ‘ ì •ì  ì¤‘ ë‚´ì°¨ìˆ˜ê°€ 0ì´ëœ ê²ƒë§Œ íì— ë„£ëŠ”ë‹¤.
3. íê°€ ë¹Œ ë•Œê¹Œì§€ ìœ„ â’ë¥¼ ì§€ì† ë°˜ë³µí•œë‹¤.
4. íê°€ ë¹„ì—ˆëŠ”ë° ì „ì²´ ì •ì ì˜ ìˆ˜ì™€ ë°©ë¬¸ ì™„ë£Œëœ ì •ì ì˜ ìˆ˜ê°€ ë‹¤ë¥´ë‹¤ë©´ Cycleì´ ìˆëŠ” ê²ƒì´ë‹¤.

### ë¬´ë°©í–¥ ê·¸ë˜í”„ ìˆœí™˜ íƒì§€
ë¬´ë°©í–¥ ê·¸ë˜í”„ëŠ” ìƒí˜¸ ì—°ê²°ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ìˆœí™˜ íƒì§€ í•˜ë“¯ì´ íƒì§€ë¥¼ ì‹œë„í•˜ë©´ ë¬´ì¡°ê±´ ìˆœí™˜ì´ ìˆëŠ” ê²ƒìœ¼ë¡œ íƒì§€ëœë‹¤.

1. ê·¸ë˜í”„ë¥¼ ë§Œë“¤ê³  BFS íƒìƒ‰ í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ì—¬ í˜„ì¬ ì •ì , ë°©ë¬¸ ì—¬ë¶€ ë°°ì—´ì„ ì „ë‹¬í•œë‹¤.
2. í˜„ì¬ íƒìƒ‰ ì •ì ì„ ë°©ë¬¸ ì™„ë£Œë¡œ í‘œì‹œí•˜ê³  parentë°°ì—´ì„ ë”°ë¡œ ìƒì„±í•œ ë’¤, ìµœì´ˆ íƒìƒ‰ ì •ì ì˜ parentëŠ” -1ë¡œ ì €ì¥
  - parentëŠ” í˜„ì¬ ë…¸ë“œì™€ ì´ì–´ì§„ ì´ì „ì— íƒìƒ‰ëœ ë…¸ë“œê°€ ì €ì¥ëœ ë°°ì—´
3. BFS íƒìƒ‰ì„ ìœ„í•´ íë¥¼ ìƒì„±í•˜ê³  ìµœì´ˆ íƒìƒ‰ ìˆ˜í–‰ ì •ì ì„ íì— ë„£ëŠ”ë‹¤.
4. íê°€ ë¹„ì–´ ìˆì§€ ì•Šì€ ë™ì•ˆ ë°˜ë³µë¬¸ì„ ìˆ˜í–‰í•˜ë©° íì˜ ì •ì ì„ í•˜ë‚˜ì”© ë¹¼ê³  ë°©ë¬¸ë˜ì§€ ì•Šì€ ì¸ì ‘ ì •ì ë“¤ì„ íƒìƒ‰í•œë‹¤.
5. ì¸ì ‘ ì •ì ì´ ê¸° ë°©ë¬¸ ìƒíƒœì´ë©° parentê°€ í˜„ì¬ ì •ì  ê°’ì´ ì•„ë‹ˆë¼ë©´ ìˆœí™˜ ìˆìŒìœ¼ë¡œ ê²°ê³¼ê°’ ë°˜í™˜


## âœ¨ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
1. Bubble Sort(ë²„ë¸”ì •ë ¬): ì²« ì›ì†Œë¶€í„° ìˆœì°¨ë¡œ í˜„ì¬ ì›ì†Œê°€ ê·¸ ë‹¤ìŒ ì›ì†Œë³´ë‹¤ í¬ë©´ ë‘ ì›ì†Œë¥¼ ë°”ê¿ˆ
2. Selection Sort(ì„ íƒì •ë ¬): ë°°ì—´ì„ ì„ í˜• íƒìƒ‰(linear scan)í•˜ì—¬ ê°€ì¥ ì‘ì€ ì›ì†Œë¥¼ ì•ìœ¼ë¡œ ë³´ëƒ„
3. Insertion Sort(ì‚½ì…ì •ë ¬): ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…(insertion)í•˜ëŠ” ì •ë ¬. í•„ìš”í•  ë•Œë§Œ ìœ„ì¹˜ë¥¼ ë°”ê¾¸ë¯€ë¡œ ë°ì´í„°ê°€ ì •ë ¬ë˜ì–´ìˆì„ ë•ŒëŠ” íš¨ìœ¨ì ì„.
4. Quick Sort(í€µì •ë ¬): ì„ì˜ì˜ ê¸°ì¤€ ëŒ€ë¹„ í° ìˆ˜ì™€ ì‘ì€ ìˆ˜ë¡œ ë‚˜ëˆ„ëŠ” ë°©ì‹
5. Merge Sort(ë³‘í•©ì •ë ¬): ë°°ì—´ì„ ì ˆë°˜ì”© ë‚˜ëˆ„ì–´ ê°ê° ì •ë ¬í•˜ê³  í•©í•´ì„œ ë‹¤ì‹œ ì •ë ¬
6. Heap Sort(í™ì •ë ¬): ë£¨íŠ¸ë¥¼ í™ì˜ ë§ˆì§€ë§‰ ì›ì†Œì™€ êµí™˜í•˜ê³ , ë‚˜ë¨¸ì§€ ì›ì†Œì— ëŒ€í•´ì„œ ë°˜ë³µí•œë‹¤. ìµœëŒ€í™ì— ì›ì†Œê°€ 1ê°œ ë‚¨ìœ¼ë©´ ì¢…ë£Œ. 

![image](https://user-images.githubusercontent.com/26478398/215319623-e795abe9-2d5e-4ed7-a069-43dc2a7d9f79.png)

## âœ¨ì„ íƒ ì •ë ¬
```
array = [2, 3, 1, 4]
for i in range(len(array)):
    min_index = i # index of the smallest element
    for j in range(i+1, len(array)):
        min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap
```

## âœ¨ë¶„í• ì •ë³µ
```
array = [2, 3, 1, 4]
def quick_sort(array):
    #quit if list has one or less elements
    if len(array) <= 1:
        return array
    
    pivot = array[0] # first element as pivot
    tail = array[1:] # list accept pivot
    left = [x for x in tail if x <= pivot] # left side
    right = [x for x in tail if x > pivot] # right side
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
```

## âœ¨ Max Consecutive Number Subsequence ìµœëŒ€ ì—°ì† ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©
- ê°œë…: ì—°ì†ëœ ì›ì†Œë¥¼ ë”í•œ ë¶€ë¶„ ìˆ˜ì—´ì˜ ìµœëŒ€ê°’

### ì•Œê³ ë¦¬ì¦˜
- í˜„ì¬ í•©
- í•©ì˜ ìµœëŒ“ê°’
1. ìˆ˜ì˜ í•©ì„ ë°˜ë³µì ìœ¼ë¡œ êµ¬í•œë‹¤.
2. ì´ ë•Œ í•©ì´ ìŒìˆ˜ì´ë©´ í˜„ì¬ í•©ì€ 0ì´ë˜ê³  ê·¸ ë‹¤ìŒ ìˆ˜ë¶€í„° ë‹¤ì‹œ ì‹œì‘í•œë‹¤.
3. í•©ì˜ ìµœëŒ“ê°’ì„ ë„ì¶œí•œë‹¤.

## âœ¨ LIS(Longest Increasing Subsequence)  ìµœì¥ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ / LCS(Longest Common Subsequence) ìµœì¥ ê³µí†µ ë¶€ë¶„ ìˆ˜ì—´

- ê°œë…ì€ ê°„ë‹¨í•˜ì§€ë§Œ ì–´ë–¨ ë•Œ í•´ë‹¹ ë°©ë²•ì„ í™œìš©í• ì§€ íŒë‹¨ì´ ì–´ë µë‹¤.
- ê¸°ë³¸ì ìœ¼ë¡œ ë¶€ë¶„ ìˆ˜ì—´ êµ¬í•˜ê¸°ì— DPë¥¼ ì–¹ì€ í˜•íƒœ
- DPë¡œ í’€ë©´ O(N^2) ì´ê¸°ë•Œë¬¸ì— ì´ë¶„íƒìƒ‰ì„ í™œìš©í•´ O(logN)ìœ¼ë¡œ ìµœì í™” ê°€ëŠ¥í•˜ë‹¤.

```
import bisect

def lengthOfLIS(nums):
    arr = []
        
    for num in nums:
        insertion_pos = bisect.bisect_left(arr, num)
            
        if insertion_pos == len(arr):
            arr.append(num)
        else:
            arr[insertion_pos] = num
        
    return len(arr)
```

## Trie íŠ¸ë¼ì´ ì•Œê³ ë¦¬ì¦˜
ë¬¸ìì—´ì„ ì°¾ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

- ì‹œê°„ë³µì¡ë„: O(L)  // ë¬¸ìì—´ ê¸¸ì´ ë§Œí¼
- ì´ë¡ ì ìœ¼ë¡œëŠ” ì¢‹ì§€ë§Œ í•´ì‹œ, ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì— ë¹„í•´ í›¨ì”¬ ëŠë¦¼. ì¼ë°˜ì ì¸ ìƒí™©ì—ì„œëŠ” í•´ì‹œë‚˜ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ê³  íŠ¸ë¼ì´ë¥¼ í™œìš©í•´ì•¼í•  ë•Œë„ ìˆë‹¤.

1. ë¬¸ìë“¤ì„ ì €ì¥í•  Nodeí´ë˜ìŠ¤ë¥¼ ìƒì„±í•´ì¤€ë‹¤.
```
class Node(object):
    def __init__(self, key):
        self.key = key          # í•´ë‹¹ ë¬¸ìë¥¼ keyê°’ìœ¼ë¡œ ê°€ì§
        self.children = {}      # ìì‹ë…¸ë“œë¥¼ ë”•ì…”ë„ˆë¦¬í˜•íƒœë¡œ ì €ì¥
```
2. ë¹ˆ Nodeë¥¼ ìƒì„±í•˜ê³  self.headë¡œ ê°€ë¦¬í‚¨ë‹¤.
3. insert ë©”ì†Œë“œ (ì‚½ì…)
4. search ë©”ì†Œë“œ (íƒìƒ‰)
```
class Trie:
    def __init__(self):
        self.head = Node(None)
    
    def insert(self, string):
        cur_node = self.head
 
        for char in string:
            if char not in cur_node.children:
                # í•´ë‹¹ë¬¸ìê°€ ìì‹ë…¸ë“œì— ì—†ì„ ê²½ìš° ë…¸ë“œ ì¶”ê°€
                cur_node.children[char] = Node(char)
            cur_node = cur_node.children[char]
 
        cur_node.children['*'] = True       # ë¬¸ìì—´ì˜ ë§ˆì§€ë§‰ì— '*' ì‚½ì…
        
    def search(self, string):
        cur_node = self.head
 
        for char in string:
            if char in cur_node.children:
                cur_node = cur_node.children[char]
            else:
                return False
 
        # íŠ¸ë¦¬ì˜ ëê¹Œì§€ ê°”ì„ë•Œ ë§ˆì§€ë§‰ë…¸ë“œì˜ ìì‹ì´ '*'ì´ë©´ True ë¦¬í„´
        if '*' in cur_node.children:
            return True
```

```
trie = Trie()
trie.insert(s)
a = trie.search('leetcode')
```

## âœ¨ ë©”ëª¨ì´ì œì´ì…˜ Memoization

ë™ì¼í•œ ê³„ì‚°ì„ ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•´ì•¼ í•˜ëŠ” ê²½ìš°, í•œ ë²ˆ ê³„ì‚°í•œ ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ì— ì €ì¥í•´ ë‘ì—ˆë‹¤ê°€ í•„ìš”í•œ ê²½ìš° êº¼ë‚´ì„œ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ì¤‘ë³µ ê³„ì‚°ì„ ë°©ì§€í•˜ëŠ” ê¸°ë²•.

- ë™ì  ê³„íšë²•ì˜ í•µì‹¬ì´ ë˜ëŠ” ê¸°ìˆ 
- ë©”ëª¨ë¦¬ë¼ëŠ” ê³µê°„ ë¹„ìš©ì„ íˆ¬ì…í•´ì„œ ê³„ì‚°ì— ì†Œìš”ë˜ëŠ” ì‹œê°„ ë¹„ìš©ì„ ì¤„ì´ëŠ” ë°©ë²•ì´ë‹¤.
- ì¬ê·€ì˜ ë‹¨ì : ê°’ì´ ì»¤ì§€ë©´ ì—°ì‚°ì´ ë§ì•„ì§„ë‹¤. -> ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ í•´ê²°í•œë‹¤.

ex) í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ - mì´ë¼ëŠ” ë¦¬ìŠ¤íŠ¸ì— ì´ë¯¸ ê³„ì‚°í•œ í”¼ë³´ë‚˜ì¹˜ ê°’ì„ ë„£ì–´ë‘ê³  í•„ìš”ì—ë”°ë¼ ê°€ì ¸ì˜¨ë‹¤.
```
max_value=int(input())
m=[0]*max_value

def fibonacci(a):
    if a < 2:
        return a
    elif m[a]:
        return m[a]
    m[a] = fibonacci(a-1)+fibonacci(a-2)
    return m[a]
```

## âœ¨ê¸°íƒ€

### 2ì°¨ì› ë°°ì—´ì„ 1ì°¨ì› ë°°ì—´ë¡œ í•©ì¹˜ê¸°
```
sum(matrix,[])
```

### ì—¬ëŸ¬ ê·¸ë£¹ì˜ ë°ì´í„°ë¥¼ ë£¨í”„ë¥¼ í•œ ë²ˆë§Œ ëŒë©´ì„œ ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥ (ë¬¶ê¸°)
```
zip([1,2,3],['a','b','c']) # (1,'a'),(2,'b'),(3,'c')
```

### forë¬¸ ëŒë©´ì„œ popleftí•˜ê²Œë˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
```
import copy
for i in copy.deepcopy(workday):
```

### ë¦¬ìŠ¤íŠ¸ ë§¨ì•ì— ìš”ì†Œ ì¶”ê°€í•˜ê¸° - insert( )
```
arr.insert(0, tmp)
```

### deque
- popleft() í•„ìš”í•  ë•Œ íš¨ìœ¨ì„± ë†’ìŒ
```
from collections import deque 
workday = deque()
```

### defaultdict(int) ë¥¼ ì‚¬ìš©í•˜ë©´ if ë¯¸ë¦¬ ì¡´ì¬í•˜ëŠ”ì§€ ì²´í¬ì•ˆí•´ë„ ëœë‹¤.
- dictionaryì˜ ì´ˆê¸°ê°’ì€ 0ìœ¼ë¡œ ì§€ì •ë˜ê¸°ë•Œë¬¸ì´ë‹¤.
```
for j in strarr:
    if j in counts:
        counts[j] += 1
    else:
        counts[j] = 1
```
```
from collections import defaultdict
counts = defaultdict(int)
for j in strarr:
    counts[j] += 1
```

### ë¦¬ìŠ¤íŠ¸ ìš”ì†Œë“¤ ì‚¬ì´ì— sep êµ¬ë¶„ìë¥¼ ë„£ì–´ ì¶œë ¥í•˜ê¸°  
```
print(*answer, sep='\n')
```

### íŠœí”Œì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê¸°
```
''.join(íŠœí”Œ)
```

### ìˆ«ì ë¦¬ìŠ¤íŠ¸ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê¸°
```
''.join(map(str,ë¦¬ìŠ¤íŠ¸))
```

### ìœ¤ë…„ì€ 2ì›”ì´ 29ì¼ì´ë‹¤.

### ë¬¸ìì—´ ì •í•´ì§„ ìˆ˜ë¥¼ 0ìœ¼ë¡œ ì±„ìš°ê¸°
```
'8'.zfill(3) #008
```

### 2ì§„ìˆ˜, 8ì§„ìˆ˜, 16ì§„ìˆ˜ ë³€í™˜
```
format(N, 'b') # 2ì§„ìˆ˜ Binary format
format(N, 'o') # 8ì§„ìˆ˜ Octal format
format(N, 'x') # 16ì§„ìˆ˜ Hexadecimal format
```

### íŠ¹ì • ë¬¸ìì—´ì—ì„œ ì°¾ëŠ” ë¬¸ìì—´ì˜ ëª¨ë“  ì¸ë±ìŠ¤ ì°¾ê¸°
- finditer(íŒ¨í„´, ë¬¸ìì—´, í”Œë˜ê·¸)
```
for text in re.finditer('1', binaryNum):
    now = text.start()
```



