# algorithm

## 스택/큐
* 스택/큐 > 기능개발 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42586)
[풀이](https://github.com/nayoung240/algorithm/blob/main/functiondevlop.py)
* 스택 수열 > 👉
[문제](https://www.acmicpc.net/problem/1874)
[풀이](https://github.com/nayoung240/algorithm/blob/main/stacknumber.py)
* 스택/큐 > 주식 가격 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42584)
[풀이](https://github.com/nayoung240/algorithm/blob/main/stockprice.py)
* 1~1000에서 각 숫자의 개수 구하기 > 👉
[문제](https://codingdojang.com/scode/504)
[풀이](https://github.com/nayoung240/algorithm/blob/main/numbercount.py)
* 2019 카카오 개발자 겨울 인턴십 > 크레인 인형뽑기 게임 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/64061?language=javascript)
[풀이](https://github.com/nayoung240/algorithm/blob/main/dolldraw.js)
* 큐2 > 👉
[문제](https://www.acmicpc.net/problem/18258)
[풀이](https://github.com/nayoung240/algorithm/blob/main/queue.py)
* 2022 KAKAO TECH INTERNSHIP > 두 큐 합 같게 만들기 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/118667)
[풀이](https://github.com/nayoung240/algorithm/blob/main/samequeue.py)
* 스택/큐 > 다리를 지나는 트럭 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42583)
[풀이](https://github.com/nayoung240/algorithm/blob/main/bridge_truck.py)



## 힙/해시
* 해시 > 완주하지 못한 선수 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42576?language=python3#_=_)
[풀이](https://github.com/nayoung240/algorithm/blob/main/uncomplete.py)
* Kth Largest Element in an Array > 👉
[문제](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/kthlagest.py)
* Kth Smallest Element in a Sorted Matrix > 👉
[문제](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/kthsmallest.py)
* Group Anagrams > 👉
[문제](https://leetcode.com/problems/group-anagrams/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/groupanagram.py)
* Letter Combinations of a Phone Number > 👉
[문제](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/phonenumbercombination.py)
* 2019 KAKAO BLIND RECRUITMENT > 오픈채팅방 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42888)
[풀이](https://github.com/nayoung240/algorithm/blob/main/openchat.py)
* 2022 KAKAO BLIND RECRUITMENT > 신고 결과 받기 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
[풀이](https://github.com/nayoung240/algorithm/blob/main/reportmail.py)


## 정렬
* 정렬 > H-Index 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42747)
[풀이](https://github.com/nayoung240/algorithm/blob/main/hindex.py)
* 정렬 > 소트인사이드 👉
[문제](https://www.acmicpc.net/problem/1427)
[풀이](https://github.com/nayoung240/algorithm/blob/main/sortinside.py)
* 정렬 > 가장 큰 수 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42746?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/biggestnumber.py)


## 완전 탐색
* 완전탐색 > 카펫 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42842)
[풀이](https://github.com/nayoung240/algorithm/blob/main/carpet.py)

## 이분 탐색
* 이분탐색 > 입국심사 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
[풀이](https://github.com/nayoung240/algorithm/blob/main/immigration.py)
* 2020 KAKAO BLIND RECRUITMENT > 가사 검색 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/60060?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/searchlycies.py)


## 탐욕법 (Greedy)
* 탐욕법(Greedy) > 체육복 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/42862)
[풀이](https://github.com/nayoung240/algorithm/blob/main/gymsuit.py)


## 동적계획법 (Dynamic Programming)
* 동적계획법(Dynamic Programming) > 정수 삼각형 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43105)
[풀이](https://github.com/nayoung240/algorithm/blob/main/inttriangle.py)
* 동적계획법(Dynamic Programming) > N으로 표현 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42895)
[풀이](https://github.com/nayoung240/algorithm/blob/main/nreturn.py)
* 동적계획법(Dynamic Programming) > 도둑질 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42897)
[풀이](https://github.com/nayoung240/algorithm/blob/main/thievery.py)


## 깊이 우선 탐색 / 넓이 우선 탐색 (DFS/BFS)
* 깊이우선탐색(DFS) 타겟 넘버 > 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43165?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/targetnumber.py)
* DFS와 BFS > 👉
[문제](https://www.acmicpc.net/problem/1260)
[풀이](https://github.com/nayoung240/algorithm/blob/main/dfsbfs.py)
* 서울 지하철 2호선 > 👉
[문제](https://www.acmicpc.net/problem/16947)
[풀이](https://github.com/nayoung240/algorithm/blob/main/station2line.py)
* Numbers With Same Consecutive Differences > 👉
[문제](https://leetcode.com/problems/numbers-with-same-consecutive-differences/)
[풀이](https://github.com/nayoung240/algorithm/blob/main/samediffnum.py)


## 기타
* 2021 KAKAO BLIND RECRUITMENT > 신규 아이디 추천 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/72410)
[풀이](https://github.com/nayoung240/algorithm/blob/main/newid.js)
[풀이2](https://github.com/nayoung240/algorithm/blob/main/newid.py)
* 위클리 챌린지 > 부족한 금액 계산하기 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/82612)
[풀이](https://github.com/nayoung240/algorithm/blob/main/lackmoney.py)
* 위클리 챌린지 > 상호평가 👉
[문제](https://programmers.co.kr/learn/courses/30/lessons/83201)
[풀이](https://github.com/nayoung240/algorithm/blob/main/evaluation.py)
* 스킬 체크 테스트 Level1 👉
[문제](https://programmers.co.kr/skill_checks/403872)
[풀이](https://github.com/nayoung240/algorithm/blob/main/caldate.py)
* 2021 Dev-Matching: 웹 백엔드 개발자(상반기) > 다단계 피라미드 👉
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/77486?language=python3)
[풀이](https://github.com/nayoung240/algorithm/blob/main/pyramid.py)

<br>

## sql
* 2021 Dev-Matching: 웹 백엔드 개발자(상반기) > 헤비 유저가 소유한 장소
[문제](https://programmers.co.kr/learn/courses/30/lessons/77487)
[풀이](https://github.com/nayoung240/algorithm/blob/main/havyuser.sql)

<br>

## 코딩테스트 사이트
- 프로그래머스
- 백준
- leetcode

<br><hr><br>

# 알아두면 쓸모있는?!

## ✨입출력
### 여러줄 입력받을 때 타임아웃 걸리지 않으려면
```
import sys 
T = int(input()) 
for i in range(T): 
    a,b = map(int, sys.stdin.readline().split()) 
```

### 개행문자까지 입력받기
```
sys.stdin.readline().strip()
```

## ✨map(function, iterable)

### map을 사용하지 않으면 for문으로 번거로움
```
myList = [1, 2, 3, 4, 5]

# for 반복문 이용
result1 = []
for val in myList:
    result1.append(val + 1)
```
### map을 사용할 때
```
myList = [1, 2, 3, 4, 5]

def add_one(n):
    return n + 1

result2 = list(map(add_one, myList))  # map반환을 list 로 변환
```
### map, lamda 함수(이름없는 함수) 이용
```
result2 = list(map(lambda x: x * 2, [5, 4, 3, 2, 1]))
```

## ✨counter
- {객체값 : counter수}
- counter 객체 간 더하기, 빼기, 교집합, 합집합 연산 가능
```
import collections
answer = collections.Counter(participant) - collections.Counter(completion)
```

## ✨소수점
```
round(number) # 반올림

import math
math.ceil(number) # 올림
```

## ✨정렬
- sort(): 리스트 원본값을 수정한다, 리턴값은 None (sorted 보다 조금 빠르다)
- sorted(): 리스트 원본값은 그대로, 리턴값은 정렬값

### 중복제거&정렬하기
```
sorted(set(nums), reverse=True)
```

### lamda 인자 : 표현식 
- key인자에 정렬해줄 값을 넘겨주면 정렬된다 

### list[1]을 기준으로 정렬
```
sorted(a, key = lambda x : x[1]) # [(3, 0), (5, 1), (0, 1), (1, 2), (5, 2)]
```
### 문자열 길이를 기준으로 정렬
```
sorted(list, key=lambda x : len(x)) # ['is', 'my', 'name', 'song']
```
### 제일 큰 수 만들기
```
list.sort(key=lambda x:str(x)*3, reverse=True)
```

## ✨순열
- permutations(): 하나의 리스트에서 모든 조합 계산(순서포함)
```
from itertools import permutations
permutations(arr, 2)
```

## ✨조합
- combinations(): 하나의 리스트에서 모든 조합 계산
```
import itertools

a = itertools.combinations([2,1,3], 2)
print(list(a)) # [(2,1),(2,3),(1,3)]
```
- product(): 두개 이상의 리스트에서 모든 조합 계산
```
from itertools import product
product(*arr)
```

## ✨set 집합 자료형
- 중복을 제거한다.
- 추가: add()
- 제거: remove()
- 교집합: list(set(A) & set(B))
- 합집합: list(set(A) | set(B))
- 차집합: list(set(A) - set(B))


## ✨힙 heap

### 최소힙 (오름차순 정렬)
```
import heapq

def heapsort(iterable):
    h = []
    result = []

    #모든 원소를 차례대로 힙에 삽입
    for value in iterable:
        heapq.heappush(h,value)
    
    #힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
    for _ in range(len(h)):
        result.append(heapq.heappop(h))
    
    return result

result = heapsort([1,3,5,7,9,2,4,6,8,0])
print(result)
```

### 최대힙 (내림차순 정렬)
```
import heapq

def heapsort(iterable):
    r = []
    result = []

    for value in iterable:
        heapq.heappush(r,-value)
    
    for _ in range(len(r)):
        result.append(-heapq.heappop(r))

    return result

result = heapsort([1,3,5,7,9,2,4,6,8,0])
print(result)
```

## ✨다익스트라 알고리즘
- 최단 거리 구하기 (노드, 가중치를 가진 간선)
- 우선순위 큐 heapq : 우선순위가 가장 높은 데이터를 가장 먼저 꺼낸다
- 거리 리스트, 방문여부 리스트

1. 출발 노드 설정한다
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장한다
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택한다
4. 해당 노드를 거쳐서 특정한 노드로 가능 경우를 고려하여 최소 비용을 갱신한다
5. 3~4번 반복
```
import sys
import heapq
input = sys.stdin.readline
n, m = map(int, input().split())
start = int(input())
INF = int(1e9)

distance = [INF] * (n+1)
graph = [[] for _ in range(n+1)]

for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))


def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))  # 시작노드 정보 우선순위 큐에 삽입
    distance[start] = 0            # 시작노드->시작노드 거리 기록

    while q:
        dist, node = heapq.heappop(q)

        # 큐에서 뽑아낸 거리가 이미 갱신된 거리보다 클 경우(=방문한 셈) 무시
        if distance[node] < dist:
            continue

        # 큐에서 뽑아낸 노드와 연결된 인접노드들 탐색
        for next in graph[node]:
            cost = distance[node] + next[1]   # 시작->node거리 + node->node의인접노드 거리
            if cost < distance[next[0]]:      # cost < 시작->node의인접노드 거리
                distance[next[0]] = cost
                heapq.heappush(q, (cost, next[0]))

dijkstra(start)

for i in range(1, len(distance)):
    if distance[i] == INF:
        print('도달할 수 없음')
    else:
        print(distance[i])
```

## ✨이분탐색
```
left, right
while left <= right:
    mid = (left+right)//2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        right = mid-1
    else:
        left = mid+1
```

### bisect_left(a, x)
- 정렬된 a에 x를 삽입할 위치를 리턴한다.
- x가 이미 있으면 x위치의 앞 위치를 리턴한다.

### bisect_right(a, x)
- x가 이미 있으면 x위치의 뒤 위치를 반환한다.

=> 값이 없을 때는 같은 값 리턴
=> 값이 있을 때 왼쪽을 리턴할지 vs 오른쪽을 리턴할지 차이

## ✨DFS
1. 탐색 시작 노드를 스택에 삽입 후 방문처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.

### 스택으로 구현 "set, stack, root, visited"
```
graph = {1: set([3, 4]),
              2: set([3, 4, 5]),
              3: set([1, 5]),
              4: set([1]),
              5: set([2, 6]),
              6: set([3, 5])}
root = 1

def dfs(graph, root):
    visited = []
    stack = [root]

    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            stack += graph[n] - set(visited)
    return visited

dfs(graph, root)
```

### 재귀로 구현
```
def dfs(graph, v, visited):
    # 현재 노드 방문 처리
    visited[v] = True

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
```

### 양방향 그래프 구현 "set, deque, root, visited, sort(reverse=True)"
```
def DFS(graph, root):
    visited = []
    stack = [root]

    while stack:
        n = stack.pop()
        if n not in visited:
            visited.append(n)
            if n in graph:
                temp = list(set(graph[n]) - set(visited))
                temp.sort(reverse=True)
                stack += temp
    return " ".join(str(i) for i in visited)
```

### 사이클 찾기
```
stack = [0]
while stack:
    n = stack.pop()
    for i in adj[n]:
        if not i in visited:
            stack.append(i)
    visited.append(n)
return visited
# visited에 중복된 노드가 있을 경우 사이클이 존재한다고 판단!
```

## ✨백트래킹 backtracking
원하는 값과 불일치 하는 부분이 있으면 더이상 탐색하지 않고 전 단계로 돌아간다.
- Promising: 트리구조 기반으로 DFS 탐색하면서 조건에 부합하는지 체크
- Pruning: 조건에 맞지 않는 노드는 가지치키한다.
ex) 미로 찾기 (트리 탐색 문제로 해석), n-queens

```
n, m = map(int, input().split())
visited = [False] * (n+1)
answer = []

def dfs(depth, n, m):
  if depth == m:
    print(' '.join(map(str, answer)))

  for i in range(1, n+1):
    # 방문하지 않았을 경우
    if not visited[i]:
      visited[i] = True
      answer.append(i)
      dfs(depth+1, n, m) # depth 1 증가, 다음 노드
      visited[i] = False
      answer.pop()

dfs(0, n, m)
```

## ✨BFS
1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼내 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리 한다.

### 큐로 구현 "set, deque, root, visited"
```
from collections import deque

graph = {1: set([3, 4]),
              2: set([3, 4, 5]),
              3: set([1, 5]),
              4: set([1]),
              5: set([2, 6]),
              6: set([3, 5])}
root = 1

def bfs(graph, root):
    visited = []
    queue = deque([root])

    while queue:
        n = queue.popleft()
        if n not in visited:
            visited.append(n)
            queue += graph[n] - set(visited)
    return visited
    
bfs(graph, root)
```

### 양방향 그래프 구현 "set, deque, root, visited, sort"
```
from collections import deque

graph = {1:[2,3,4], 2:[1,4], 3:[1,4], 4:[1,2,3]}
root = 1

def BFS(graph, root):
    visited = []
    queue = deque([root])

    while queue:
        n = queue.popleft()
        if n not in visited:
            visited.append(n)
            if n in graph:
                temp = list(set(graph[n]) - set(visited))
                temp.sort()
                queue += temp
    return " ".join(str(i) for i in visited)
    
BFS(graph, root)
```

### 방향 그래프 순환 탐지

1. 최초에 내차수가 0인 정점을 모두 찾아 각 정점을 큐에 넣는다.
2. 큐에서 하나씩 빼서 방문 완료 처리하고 방문 완료 정점의 수를 1 늘리고, 해당 정점의 인접 정점의 내차수를 1씩 뺀 다음, 인접 정점 중 내차수가 0이된 것만 큐에 넣는다.
3. 큐가 빌 때까지 위 ⒝를 지속 반복한다.
4. 큐가 비었는데 전체 정점의 수와 방문 완료된 정점의 수가 다르다면 Cycle이 있는 것이다.

### 무방향 그래프 순환 탐지
무방향 그래프는 상호 연결되어 있기 때문에 방향 그래프에서 순환 탐지 하듯이 탐지를 시도하면 무조건 순환이 있는 것으로 탐지된다.

1. 그래프를 만들고 BFS 탐색 함수를 생성하여 현재 정점, 방문 여부 배열을 전달한다.
2. 현재 탐색 정점을 방문 완료로 표시하고 parent배열을 따로 생성한 뒤, 최초 탐색 정점의 parent는 -1로 저장
  - parent는 현재 노드와 이어진 이전에 탐색된 노드가 저장된 배열
3. BFS 탐색을 위해 큐를 생성하고 최초 탐색 수행 정점을 큐에 넣는다.
4. 큐가 비어 있지 않은 동안 반복문을 수행하며 큐의 정점을 하나씩 빼고 방문되지 않은 인접 정점들을 탐색한다.
5. 인접 정점이 기 방문 상태이며 parent가 현재 정점 값이 아니라면 순환 있음으로 결과값 반환


## ✨정렬 알고리즘
- Bubble Sort(버블정렬): 첫 원소부터 순차로 현재 원소가 그 다음 원소보다 크면 두 원소를 바꿈
- Selection Sort(선택정렬): 배열을 선형 탐색(linear scan)하여 가장 작은 원소를 앞으로 보냄
- Insertion Sort(삽입정렬): 적절한 위치에 삽입(insertion)하는 정렬. 필요할 때만 위치를 바꾸므로 데이터가 정렬되어있을 때는 효율적임.
- Quick Sort(퀵정렬): 임의의 기준 대비 큰 수와 작은 수로 나누는 방식
- Merge Sort(병합정렬): 배열을 절반씩 나누어 각각 정렬하고 합해서 다시 정렬

## ✨선택 정렬
```
array = [2, 3, 1, 4]
for i in range(len(array)):
    min_index = i # index of the smallest element
    for j in range(i+1, len(array)):
        min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap
```

## ✨분할정복
```
array = [2, 3, 1, 4]
def quick_sort(array):
    #quit if list has one or less elements
    if len(array) <= 1:
        return array
    
    pivot = array[0] # first element as pivot
    tail = array[1:] # list accept pivot
    left = [x for x in tail if x <= pivot] # left side
    right = [x for x in tail if x > pivot] # right side
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
```

## ✨기타

### 2차원 배열을 1차원 배열로 합치기
```
sum(matrix,[])
```

### 여러 그룹의 데이터를 루프를 한 번만 돌면서 병렬 처리 가능 (묶기)
```
zip([1,2,3],['a','b','c']) # (1,'a'),(2,'b'),(3,'c')
```

### for문 돌면서 popleft하게되면 에러가 발생한다.
```
import copy
for i in copy.deepcopy(workday):
```

### deque
- popleft() 필요할 때 효율성 높음
```
from collections import deque 
workday = deque()
```

### defaultdict(int) 를 사용하면 if 미리 존재하는지 체크안해도 된다.
- dictionary의 초기값은 0으로 지정되기때문이다.
```
for j in strarr:
    if j in counts:
        counts[j] += 1
    else:
        counts[j] = 1
```
```
from collections import defaultdict
counts = defaultdict(int)
for j in strarr:
    counts[j] += 1
```

### 리스트 요소들 사이에 sep 구분자를 넣어 출력하기  
```
print(*answer, sep='\n')
```

### 튜플을 문자열로 변환하기
```
''.join(튜플)
```

### 숫자 리스트를 문자열로 변환하기
```
''.join(map(str,리스트))
```

### 윤년은 2월이 29일이다.

### 문자열 정해진 수를 0으로 채우기
```
'8'.zfill(3) #008
```


